/*
Oscillation features analysis
Copyright (C) 2012 Ahmet Ay, Jack Holland, Adriana Sperlea

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
The program analyzes the oscillation features (period, amplitude and peak to trough ratio)
for oscillatory cell behavior described in the input file.
The format of the input file is
t c1(t) c2(t) . . . cn(t),
where t is the time step and ci(t) is the value of cell i at time step t.
Since we assume that our cells are in synchrony and the simulations are stochastic, the program
averages the value of all the periods, amplitudes and peak to troughs ratios for each individual cell
and outputs only one number for each of them. 

All the values computed are printed to the files period.txt, amplitude.txt and peaktotrough.txt.
Line i in each of the files contains the values of the oscillation feature indicated by the file name for cell i.
*/

#include <iostream>
#include <fstream>
#include <string>
#include <string.h>
#include <cmath>
#include <sys/stat.h>
#include <errno.h>
#include <stdlib.h>

using namespace std;

int findLastSlash(char* filename) {
	/*	
	Finds the parent directory of filename.
	Used to determine the output directory of the period.txt, amplitude.txt and peaktotrough.txt files.
	*/	
	for (int i = strlen(filename) - 1; i >= 0; i--) {
		if (filename[i] == '/') {
			return i;
		}
	}
	return -1;
}

int main(int argc, char** argv) {
	/* The program takes 3 parameters:
	1) The name of the file containing the rough or unsmoothed data.
	   The unsmoothed data is used to calculate the values of the peaks and troughs.
	2) The name of the file containing the smoothed data.
	   The smoothed data is used to calculate the period, in order to eliminate occurences of false peaks or troughs generated by noise.
	3) The time step from which the analysis should start.*/
    ifstream rough, smooth;
    char *roughfile, *smoothfile;
	int cut;
	if (argc == 4) {
		roughfile = argv[1];
		smoothfile = argv[2];
		cut = atoi(argv[3]);
	} else {
		cerr << "ofeatures.cpp requires exactly 3 parameters: rough data file, smooth data file, time step from which to start analysis -- " << argc - 1 << " given." << endl;
		exit(0);
	}
	
	rough.open(roughfile, fstream::in);
	smooth.open(smoothfile, fstream::in);
	
	// Count the number of lines in the input file
	int nolines = 0;
	string line;
	while (!rough.eof()) { 
		getline(rough, line);
		nolines++;
	}
	rough.close();
	rough.open(roughfile, fstream::in);
	
	int w, h; // width and height of the cell grid
	rough >> w >> h;
	smooth >> w >> h;
	
	const int CELLS = w * h;
	const int FSIZE = nolines - 1;
	
	double mh1[CELLS][FSIZE]; // stores smoothed data
	double mh1n[CELLS][FSIZE]; // stores unsmoothed data
	double time[FSIZE]; // stores time steps
	double peaks[CELLS][FSIZE / 10], troughs[CELLS][FSIZE / 10], peaktime[CELLS][FSIZE / 10], troughtime[CELLS][FSIZE / 10]; // store peaks, troughs and their respective time steps
	memset(peaks, 0, sizeof(peaks));
	memset(troughs, 0, sizeof(troughs));
	memset(peaktime, 0, sizeof(peaktime));
	memset(troughtime, 0, sizeof(troughtime));
	double sumpeaks = 0, sumtroughs = 0, nopeaks = 0, notroughs = 0;
	
	int index = 0;
	double timetemp;
	
	while (!rough.eof() && !smooth.eof()) {
		rough >> time[index];
		smooth >> timetemp;
		for (int n = 0; n < CELLS; n++) {
			smooth >> mh1[n][index];
			rough >> mh1n[n][index];
		}
		index++;
	}
	
	int pos[CELLS][2];
	for (int n = 0; n < CELLS; n++) {
		pos[n][0] = 0;
		pos[n][1] = 0;
	}
	
	for (int n = 0; n < CELLS; n++) {
		for (int t = (index > 300 ? cut : 1); t < index - 1; t++) {
			if ((mh1[n][t + 1] <= mh1[n][t] && mh1[n][t] > mh1[n][t - 1]) || (mh1[n][t + 1] < mh1[n][t] && mh1[n][t] >= mh1[n][t - 1])) {
				if (abs(time[t] - peaktime[n][pos[n][0] - 1]) > 10) {
					// find the max of 5 to the left and 5 to the right							
					double maxval = 0;
					bool ispeak = true;
					for (int j = t - 1; j >= 0 && j >= t - 5; j--) {
						if (mh1n[n][j] > maxval) {
							maxval = mh1n[n][j];
						}
					}
					for (int j = t - 1; j >= 0 && j >= t - 50; j --) {
						if (mh1[n][j] > mh1[n][t]) {
							ispeak = false;
						}
					}
					for (int j = t + 1; j < index - 1 && j <= t + 5; j++) {
						if (mh1[n][j] > maxval) {
							maxval = mh1n[n][j];
						}
					}
					for (int j = t + 1; j < index - 1 && j <= t + 50; j++) {
						if (mh1[n][j] > mh1[n][t]) {
							ispeak = false;
						}
					}
					if (ispeak) {
						sumpeaks += maxval;
						nopeaks ++;
						peaks[n][pos[n][0]] = maxval;
						peaktime[n][pos[n][0]] = time[t];
						pos[n][0] ++;
					}
				}
			}
			
			if ((mh1[n][t + 1] >= mh1[n][t] && mh1[n][t] < mh1[n][t - 1]) || (mh1[n][t + 1] > mh1[n][t] && mh1[n][t] <= mh1[n][t - 1])){
				if (abs(time[t] - troughtime[n][pos[n][1] - 1]) > 10) {

					// find the min of 5 to the left and 5 to the right							
					double minval = 99999999;
					bool istrough = true;
					for (int j = t - 1; j >= 0 && j >= t - 50; j--) {
						if (mh1n[n][j] < minval) {
							minval = mh1n[n][j];
						}
					}
					for (int j = t - 1; j >= 0 && j >= t - 50; j --) {
						if (mh1[n][j] < mh1[n][t]) {
							istrough = false;
						}
					}
					for (int j = t + 1; j < index - 1 && j <= t + 50; j++) {
						if (mh1n[n][j] < minval) {
							minval = mh1n[n][j];
						}
					}
					for (int j = t + 1; j < index - 1 && j <= t + 50; j++) {
						if (mh1[n][j] < mh1[n][t]) {
							istrough = false;
						}
					}
					if (istrough) {
						sumtroughs += minval;
						notroughs ++;
						troughs[n][pos[n][1]] = minval;
						troughtime[n][pos[n][1]] = time[t];
						pos[n][1] ++;
					}
				}
			}
		}
	}

	double avgpeak = sumpeaks / nopeaks;
	double avgtrough = sumtroughs / notroughs;
	
	double stdevpeak = 0, stdevtrough = 0;
	for (int n = 0; n < CELLS; n++) {
		for (int i = 0; i < pos[n][0]; i++) {
			stdevpeak += ((peaks[n][i] - avgpeak) * (peaks[n][i] - avgpeak));
		}
		for (int i = 0; i < pos[n][1]; i++) {
			stdevtrough += ((troughs[n][i] - avgtrough) * (troughs[n][i] - avgtrough));
		}
	}
	stdevpeak /= (nopeaks - 1);
	stdevtrough /= (notroughs - 1);
	stdevpeak = sqrt(stdevpeak);
	stdevtrough = sqrt(stdevtrough);
	
	char *oname, *oname1, *oname2, *oname3;
	int slashpos = findLastSlash(roughfile);
	oname = new char[slashpos + 20];
	oname1 = new char[slashpos + 40];
	oname2 = new char[slashpos + 40];
	oname3 = new char[slashpos + 40];
	strcpy(oname, roughfile);
	oname[slashpos + 1] = '\0';
	
	strcpy(oname1, oname);
	strcpy(oname2, oname);
	strcpy(oname3, oname);
	
	ofstream per, amp, pt;
	strcat(oname1, "period.txt");
	strcat(oname2, "amplitude.txt");
	strcat(oname3, "peaktotrough.txt");

	per.open(oname1, fstream::out);
	amp.open(oname2, fstream::out);
	pt.open(oname3, fstream::out);

	double peravg = 0.0, ptavg = 0.0, ampavg = 0.0;
	int perno = 0, ptno = 0, ampno = 0;
	for (int n = 0; n < CELLS; n++) {
		int curtrough = 0;
		int curpeak = 0;
		int nexttrough = curtrough + 1;

		while (curtrough < pos[n][1] && nexttrough < pos[n][1] && curpeak < pos[n][0]) {
			peravg += (troughtime[n][nexttrough] - troughtime[n][curtrough]);
			perno++;		
			per << troughtime[n][nexttrough] - troughtime[n][curtrough] << " ";
			double tempavg = (troughs[n][curtrough] + troughs[n][nexttrough]) / 2;
			if (tempavg < 1.0) {
				tempavg = 1.0;
			}
			ptavg += (peaks[n][curpeak] / tempavg);
			ptno++;			
			pt << peaks[n][curpeak] / tempavg << " ";
			ampavg += (peaks[n][curpeak] - tempavg);
			ampno++;			
			amp << peaks[n][curpeak] - tempavg << " ";
			curpeak++;
			curtrough = nexttrough;
			nexttrough++;

		}
		per << endl;
		amp << endl;
		pt << endl;
	}
	
	cout << peravg / perno << "," << ampavg / ampno << "," << ptavg / ptno << endl;
	per.close();
	amp.close();
	pt.close();
	    
    return 0;
}
